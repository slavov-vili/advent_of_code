package main

import (
    "bufio"
    "fmt"
    "os"
    "strconv"
    "strings"
)   //end imports


func main() {
    // create a scanner to read the input
    var scanner = bufio.NewScanner(os.Stdin);
    // stores how many pairs should be considered when running the generators
    var pair_count int;
    // factors used when multiplying the previous number for each generator
    const gen_A_factor     = 16807;
    const gen_B_factor     = 48271;
    // numbers used to determine which output of the generators is eligible for submission
    const gen_A_filter     = 4;
    const gen_B_filter     = 8;
    // number to use when dividing after multiplication
    const gen_both_divisor = 2147483647;

    // while input is being received
    println("Input:")
    for scanner.Scan() {
        // split the input in 2
        var input_parts   = strings.Fields(scanner.Text());
        // store the start values of both generators
        var gen_A_start,_ = strconv.Atoi(input_parts[0]);
        var gen_B_start,_ = strconv.Atoi(input_parts[1]);

        // PART I

        // make the 2 generators
        var gen_A = Generator{gen_A_start, gen_A_start, gen_A_factor, gen_both_divisor};
        var gen_B = Generator{gen_B_start, gen_B_start, gen_B_factor, gen_both_divisor};

        pair_count = 40000000;
        var whole_output_equal_count  = judge_whole_output(gen_A, gen_B, pair_count);
        fmt.Println("The 2 generators have", whole_output_equal_count, "total numbers in common");


        // PART II

        // remake the 2 generators
        gen_A = Generator{gen_A_start, gen_A_start, gen_A_factor, gen_both_divisor};
        gen_B = Generator{gen_B_start, gen_B_start, gen_B_factor, gen_both_divisor};

        pair_count = 5000000;
        var sparse_output_equal_count = judge_sparse_output(gen_A, gen_B, gen_A_filter, gen_B_filter, pair_count);
        fmt.Println("The 2 generators have", sparse_output_equal_count, "special numbers in common");
    }   //end for
}   //end main



// generate pairs of numbers and compare them
func judge_whole_output(gen_A Generator, gen_B Generator, pair_count int) (count int) {
    // for each pair of values
    for i := 0; i<pair_count; i++ {
        // compare the numbers generated by the two generators
        if outputs_equal(gen_A.Generate_value(), gen_B.Generate_value()) {
            count++;
        }   //end if
    }   //end for
    return;
}   //end func


// generate numbers more carefully and compare them
func judge_sparse_output(gen_A Generator,  gen_B Generator,
                         gen_A_filter int, gen_B_filter int,
                                           pair_count int) (count int) {
    // store the next number generated by each generator
    var gen_A_output, gen_B_output int;

    // for each pair of values
    for i:=0; i<pair_count; i++ {

        // iterate
        for {
            // generate a new number
            gen_A_output = gen_A.Generate_value();
            // if the number is eligible for output
            if (gen_A_output % gen_A_filter) == 0 {
                break;
            }   //end if
        }   //end for

        // iterate
        for {
            // generate a new number
            gen_B_output = gen_B.Generate_value();
            // if the number is eligible for output
            if (gen_B_output % gen_B_filter) == 0 {
                break;
            }   //end if
        }   //end for

        // if the the pair of numbers is equal
        if outputs_equal(gen_A_output, gen_B_output) { count++; }   //end if
    }   //end for
    return;
}   //end func


func outputs_equal(gen_A_output, gen_B_output int) bool {
    // extract the lowest 16 bits for both numbers
    var num_A_bits = int16(gen_A_output);
    var num_B_bits = int16(gen_B_output);

    if num_A_bits == num_B_bits {
        return true;
    }   //end if

    return false;
}   //end func



type Generator struct {
    start_value int
    prev_value  int
    factor      int
    divisor     int
}   //end type

// produces and returns the next value in the generator
func (gen *Generator) Generate_value() int {
    gen.prev_value = ((gen.prev_value * gen.factor) % gen.divisor);

    return gen.prev_value;
}   //end func
